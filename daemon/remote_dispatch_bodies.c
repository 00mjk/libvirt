/* Automatically generated by remote_generator.pl.
 * Do not edit this file.  Any changes you make will be lost.
 */


/* remoteDispatchAuthList has to be implemented manually */

/* remoteDispatchAuthPolkit has to be implemented manually */

/* remoteDispatchAuthSaslInit has to be implemented manually */

/* remoteDispatchAuthSaslStart has to be implemented manually */

/* remoteDispatchAuthSaslStep has to be implemented manually */

/* remoteDispatchClose has to be implemented manually */

/* remoteDispatchCpuBaseline has to be implemented manually */

/* remoteDispatchCpuCompare has to be implemented manually */

static int
remoteDispatchDomainAbortJob(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_abort_job_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainAbortJob(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainAttachDevice(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_attach_device_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainAttachDevice(dom, args->xml) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainAttachDeviceFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_attach_device_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainAttachDeviceFlags(dom, args->xml, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainBlockPeek has to be implemented manually */

/* remoteDispatchDomainBlockStats has to be implemented manually */

static int
remoteDispatchDomainCoreDump(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_core_dump_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainCoreDump(dom, args->to, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainCreate(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainCreateWithFlags has to be implemented manually */

/* remoteDispatchDomainCreateXml has to be implemented manually */

/* remoteDispatchDomainDefineXml has to be implemented manually */

static int
remoteDispatchDomainDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainDestroy(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainDetachDevice(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_detach_device_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainDetachDevice(dom, args->xml) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainDetachDeviceFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_detach_device_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainDetachDeviceFlags(dom, args->xml, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainDumpXml has to be implemented manually */

/* remoteDispatchDomainEventsDeregister has to be implemented manually */

/* remoteDispatchDomainEventsDeregisterAny has to be implemented manually */

/* remoteDispatchDomainEventsRegister has to be implemented manually */

/* remoteDispatchDomainEventsRegisterAny has to be implemented manually */

/* remoteDispatchDomainGetAutostart has to be implemented manually */

/* remoteDispatchDomainGetBlkioParameters has to be implemented manually */

/* remoteDispatchDomainGetBlockInfo has to be implemented manually */

/* remoteDispatchDomainGetInfo has to be implemented manually */

/* remoteDispatchDomainGetJobInfo has to be implemented manually */

/* remoteDispatchDomainGetMaxMemory has to be implemented manually */

/* remoteDispatchDomainGetMaxVcpus has to be implemented manually */

/* remoteDispatchDomainGetMemoryParameters has to be implemented manually */

/* remoteDispatchDomainGetOsType has to be implemented manually */

/* remoteDispatchDomainGetSchedulerParameters has to be implemented manually */

/* remoteDispatchDomainGetSchedulerType has to be implemented manually */

/* remoteDispatchDomainGetSecurityLabel has to be implemented manually */

/* remoteDispatchDomainGetVcpus has to be implemented manually */

/* remoteDispatchDomainGetVcpusFlags has to be implemented manually */

/* remoteDispatchDomainHasCurrentSnapshot has to be implemented manually */

/* remoteDispatchDomainHasManagedSaveImage has to be implemented manually */

/* remoteDispatchDomainInterfaceStats has to be implemented manually */

/* remoteDispatchDomainIsActive has to be implemented manually */

/* remoteDispatchDomainIsPersistent has to be implemented manually */

/* remoteDispatchDomainIsUpdated has to be implemented manually */

/* remoteDispatchDomainLookupById has to be implemented manually */

/* remoteDispatchDomainLookupByName has to be implemented manually */

/* remoteDispatchDomainLookupByUuid has to be implemented manually */

static int
remoteDispatchDomainManagedSave(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_managed_save_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainManagedSave(dom, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainManagedSaveRemove(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_managed_save_remove_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainManagedSaveRemove(dom, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainMemoryPeek has to be implemented manually */

/* remoteDispatchDomainMemoryStats has to be implemented manually */

/* remoteDispatchDomainMigrateFinish has to be implemented manually */

/* remoteDispatchDomainMigrateFinish2 has to be implemented manually */

/* remoteDispatchDomainMigratePerform has to be implemented manually */

/* remoteDispatchDomainMigratePrepare has to be implemented manually */

/* remoteDispatchDomainMigratePrepare2 has to be implemented manually */

/* remoteDispatchDomainMigratePrepareTunnel has to be implemented manually */

static int
remoteDispatchDomainMigrateSetMaxDowntime(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_migrate_set_max_downtime_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainMigrateSetMaxDowntime(dom, args->downtime, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainMigrateSetMaxSpeed(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_migrate_set_max_speed_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainMigrateSetMaxSpeed(dom, args->bandwidth, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainOpenConsole has to be implemented manually */

/* remoteDispatchDomainPinVcpu has to be implemented manually */

static int
remoteDispatchDomainReboot(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_reboot_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainReboot(dom, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainRestore(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_restore_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }


    if (virDomainRestore(conn, args->from) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);

    return rv;
}

static int
remoteDispatchDomainResume(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_resume_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainResume(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainRevertToSnapshot(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_revert_to_snapshot_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    virDomainSnapshotPtr snapshot = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->snap.dom)))
        goto cleanup;

    if (!(snapshot = get_nonnull_domain_snapshot(dom, args->snap)))
        goto cleanup;

    if (virDomainRevertToSnapshot(snapshot, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (snapshot)
        virDomainSnapshotFree(snapshot);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSave(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_save_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSave(dom, args->to) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_autostart_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetAutostart(dom, args->autostart) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSetBlkioParameters has to be implemented manually */

static int
remoteDispatchDomainSetMaxMemory(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_max_memory_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetMaxMemory(dom, args->memory) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetMemory(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_memory_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetMemory(dom, args->memory) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetMemoryFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_memory_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetMemoryFlags(dom, args->memory, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSetMemoryParameters has to be implemented manually */

/* remoteDispatchDomainSetSchedulerParameters has to be implemented manually */

static int
remoteDispatchDomainSetVcpus(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_vcpus_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetVcpus(dom, args->nvcpus) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetVcpusFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_vcpus_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetVcpusFlags(dom, args->nvcpus, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainShutdown(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_shutdown_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainShutdown(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSnapshotCreateXml has to be implemented manually */

/* remoteDispatchDomainSnapshotCurrent has to be implemented manually */

static int
remoteDispatchDomainSnapshotDelete(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_snapshot_delete_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    virDomainSnapshotPtr snapshot = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->snap.dom)))
        goto cleanup;

    if (!(snapshot = get_nonnull_domain_snapshot(dom, args->snap)))
        goto cleanup;

    if (virDomainSnapshotDelete(snapshot, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (snapshot)
        virDomainSnapshotFree(snapshot);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSnapshotDumpXml has to be implemented manually */

/* remoteDispatchDomainSnapshotListNames has to be implemented manually */

/* remoteDispatchDomainSnapshotLookupByName has to be implemented manually */

/* remoteDispatchDomainSnapshotNum has to be implemented manually */

static int
remoteDispatchDomainSuspend(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_suspend_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSuspend(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainUndefine(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainUpdateDeviceFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_update_device_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainUpdateDeviceFlags(dom, args->xml, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainXmlFromNative has to be implemented manually */

/* remoteDispatchDomainXmlToNative has to be implemented manually */

/* remoteDispatchFindStoragePoolSources has to be implemented manually */

/* remoteDispatchGetCapabilities has to be implemented manually */

/* remoteDispatchGetHostname has to be implemented manually */

/* remoteDispatchGetLibVersion has to be implemented manually */

/* remoteDispatchGetMaxVcpus has to be implemented manually */

/* remoteDispatchGetSysinfo has to be implemented manually */

/* remoteDispatchGetType has to be implemented manually */

/* remoteDispatchGetUri has to be implemented manually */

/* remoteDispatchGetVersion has to be implemented manually */

static int
remoteDispatchInterfaceCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virInterfacePtr iface = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if (virInterfaceCreate(iface, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

/* remoteDispatchInterfaceDefineXml has to be implemented manually */

static int
remoteDispatchInterfaceDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virInterfacePtr iface = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if (virInterfaceDestroy(iface, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

/* remoteDispatchInterfaceGetXmlDesc has to be implemented manually */

/* remoteDispatchInterfaceIsActive has to be implemented manually */

/* remoteDispatchInterfaceLookupByMacString has to be implemented manually */

/* remoteDispatchInterfaceLookupByName has to be implemented manually */

static int
remoteDispatchInterfaceUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virInterfacePtr iface = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if (virInterfaceUndefine(iface) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

/* remoteDispatchIsSecure has to be implemented manually */

/* remoteDispatchListDefinedDomains has to be implemented manually */

/* remoteDispatchListDefinedInterfaces has to be implemented manually */

/* remoteDispatchListDefinedNetworks has to be implemented manually */

/* remoteDispatchListDefinedStoragePools has to be implemented manually */

/* remoteDispatchListDomains has to be implemented manually */

/* remoteDispatchListInterfaces has to be implemented manually */

/* remoteDispatchListNetworks has to be implemented manually */

/* remoteDispatchListNwfilters has to be implemented manually */

/* remoteDispatchListSecrets has to be implemented manually */

/* remoteDispatchListStoragePools has to be implemented manually */

static int
remoteDispatchNetworkCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkCreate(net) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

/* remoteDispatchNetworkCreateXml has to be implemented manually */

/* remoteDispatchNetworkDefineXml has to be implemented manually */

static int
remoteDispatchNetworkDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkDestroy(net) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

/* remoteDispatchNetworkDumpXml has to be implemented manually */

/* remoteDispatchNetworkGetAutostart has to be implemented manually */

/* remoteDispatchNetworkGetBridgeName has to be implemented manually */

/* remoteDispatchNetworkIsActive has to be implemented manually */

/* remoteDispatchNetworkIsPersistent has to be implemented manually */

/* remoteDispatchNetworkLookupByName has to be implemented manually */

/* remoteDispatchNetworkLookupByUuid has to be implemented manually */

static int
remoteDispatchNetworkSetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_set_autostart_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkSetAutostart(net, args->autostart) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

static int
remoteDispatchNetworkUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkUndefine(net) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

/* remoteDispatchNodeDeviceCreateXml has to be implemented manually */

static int
remoteDispatchNodeDeviceDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceDestroy(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

static int
remoteDispatchNodeDeviceDettach(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_dettach_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceDettach(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

/* remoteDispatchNodeDeviceDumpXml has to be implemented manually */

/* remoteDispatchNodeDeviceGetParent has to be implemented manually */

/* remoteDispatchNodeDeviceListCaps has to be implemented manually */

/* remoteDispatchNodeDeviceLookupByName has to be implemented manually */

/* remoteDispatchNodeDeviceNumOfCaps has to be implemented manually */

static int
remoteDispatchNodeDeviceReAttach(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_re_attach_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceReAttach(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

static int
remoteDispatchNodeDeviceReset(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_reset_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceReset(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

/* remoteDispatchNodeGetCellsFreeMemory has to be implemented manually */

/* remoteDispatchNodeGetFreeMemory has to be implemented manually */

/* remoteDispatchNodeGetInfo has to be implemented manually */

/* remoteDispatchNodeGetSecurityModel has to be implemented manually */

/* remoteDispatchNodeListDevices has to be implemented manually */

/* remoteDispatchNodeNumOfDevices has to be implemented manually */

/* remoteDispatchNumOfDefinedDomains has to be implemented manually */

/* remoteDispatchNumOfDefinedInterfaces has to be implemented manually */

/* remoteDispatchNumOfDefinedNetworks has to be implemented manually */

/* remoteDispatchNumOfDefinedStoragePools has to be implemented manually */

/* remoteDispatchNumOfDomains has to be implemented manually */

/* remoteDispatchNumOfInterfaces has to be implemented manually */

/* remoteDispatchNumOfNetworks has to be implemented manually */

/* remoteDispatchNumOfNwfilters has to be implemented manually */

/* remoteDispatchNumOfSecrets has to be implemented manually */

/* remoteDispatchNumOfStoragePools has to be implemented manually */

/* remoteDispatchNWFilterDefineXml has to be implemented manually */

/* remoteDispatchNWFilterGetXmlDesc has to be implemented manually */

/* remoteDispatchNWFilterLookupByName has to be implemented manually */

/* remoteDispatchNWFilterLookupByUuid has to be implemented manually */

static int
remoteDispatchNWFilterUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_nwfilter_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNWFilterPtr nwfilter = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(nwfilter = get_nonnull_nwfilter(conn, args->nwfilter)))
        goto cleanup;

    if (virNWFilterUndefine(nwfilter) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (nwfilter)
        virNWFilterFree(nwfilter);
    return rv;
}

/* remoteDispatchOpen has to be implemented manually */

/* remoteDispatchSecretDefineXml has to be implemented manually */

/* remoteDispatchSecretGetValue has to be implemented manually */

/* remoteDispatchSecretGetXmlDesc has to be implemented manually */

/* remoteDispatchSecretLookupByUsage has to be implemented manually */

/* remoteDispatchSecretLookupByUuid has to be implemented manually */

static int
remoteDispatchSecretSetValue(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_secret_set_value_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virSecretPtr secret = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(secret = get_nonnull_secret(conn, args->secret)))
        goto cleanup;

    if (virSecretSetValue(secret, (const unsigned char *)args->value.value_val, args->value.value_len, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (secret)
        virSecretFree(secret);
    return rv;
}

static int
remoteDispatchSecretUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_secret_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virSecretPtr secret = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(secret = get_nonnull_secret(conn, args->secret)))
        goto cleanup;

    if (virSecretUndefine(secret) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (secret)
        virSecretFree(secret);
    return rv;
}

static int
remoteDispatchStoragePoolBuild(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_build_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolBuild(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolCreate(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

/* remoteDispatchStoragePoolCreateXml has to be implemented manually */

/* remoteDispatchStoragePoolDefineXml has to be implemented manually */

static int
remoteDispatchStoragePoolDelete(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_delete_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolDelete(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolDestroy(pool) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

/* remoteDispatchStoragePoolDumpXml has to be implemented manually */

/* remoteDispatchStoragePoolGetAutostart has to be implemented manually */

/* remoteDispatchStoragePoolGetInfo has to be implemented manually */

/* remoteDispatchStoragePoolIsActive has to be implemented manually */

/* remoteDispatchStoragePoolIsPersistent has to be implemented manually */

/* remoteDispatchStoragePoolListVolumes has to be implemented manually */

/* remoteDispatchStoragePoolLookupByName has to be implemented manually */

/* remoteDispatchStoragePoolLookupByUuid has to be implemented manually */

/* remoteDispatchStoragePoolLookupByVolume has to be implemented manually */

/* remoteDispatchStoragePoolNumOfVolumes has to be implemented manually */

static int
remoteDispatchStoragePoolRefresh(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_refresh_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolRefresh(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolSetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_set_autostart_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolSetAutostart(pool, args->autostart) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolUndefine(pool) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

/* remoteDispatchStorageVolCreateXml has to be implemented manually */

/* remoteDispatchStorageVolCreateXmlFrom has to be implemented manually */

static int
remoteDispatchStorageVolDelete(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_vol_delete_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStorageVolPtr vol = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(vol = get_nonnull_storage_vol(conn, args->vol)))
        goto cleanup;

    if (virStorageVolDelete(vol, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (vol)
        virStorageVolFree(vol);
    return rv;
}

/* remoteDispatchStorageVolDownload has to be implemented manually */

/* remoteDispatchStorageVolDumpXml has to be implemented manually */

/* remoteDispatchStorageVolGetInfo has to be implemented manually */

/* remoteDispatchStorageVolGetPath has to be implemented manually */

/* remoteDispatchStorageVolLookupByKey has to be implemented manually */

/* remoteDispatchStorageVolLookupByName has to be implemented manually */

/* remoteDispatchStorageVolLookupByPath has to be implemented manually */

/* remoteDispatchStorageVolUpload has to be implemented manually */

static int
remoteDispatchStorageVolWipe(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_vol_wipe_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStorageVolPtr vol = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(vol = get_nonnull_storage_vol(conn, args->vol)))
        goto cleanup;

    if (virStorageVolWipe(vol, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (vol)
        virStorageVolFree(vol);
    return rv;
}

/* remoteDispatchSupportsFeature has to be implemented manually */
