/* Automatically generated by remote_generator.pl.
 * Do not edit this file.  Any changes you make will be lost.
 */


/* remoteDispatchAuthList has to be implemented manually */

/* remoteDispatchAuthPolkit has to be implemented manually */

/* remoteDispatchAuthSaslInit has to be implemented manually */

/* remoteDispatchAuthSaslStart has to be implemented manually */

/* remoteDispatchAuthSaslStep has to be implemented manually */

/* remoteDispatchClose has to be implemented manually */

/* remoteDispatchCpuBaseline has to be implemented manually */

/* remoteDispatchCpuCompare has to be implemented manually */

static int
remoteDispatchDomainAbortJob(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_abort_job_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainAbortJob(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainAttachDevice(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_attach_device_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainAttachDevice(dom, args->xml) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainAttachDeviceFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_attach_device_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainAttachDeviceFlags(dom, args->xml, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainBlockPeek has to be implemented manually */

/* remoteDispatchDomainBlockStats has to be implemented manually */

static int
remoteDispatchDomainCoreDump(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_core_dump_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainCoreDump(dom, args->to, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainCreate(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainCreateWithFlags has to be implemented manually */

/* remoteDispatchDomainCreateXML has to be implemented manually */

/* remoteDispatchDomainDefineXML has to be implemented manually */

static int
remoteDispatchDomainDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainDestroy(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainDetachDevice(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_detach_device_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainDetachDevice(dom, args->xml) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainDetachDeviceFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_detach_device_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainDetachDeviceFlags(dom, args->xml, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainDumpXML(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_dump_xml_args *args,
    remote_domain_dump_xml_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((xml = virDomainGetXMLDesc(dom, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainEventsDeregister has to be implemented manually */

/* remoteDispatchDomainEventsDeregisterAny has to be implemented manually */

/* remoteDispatchDomainEventsRegister has to be implemented manually */

/* remoteDispatchDomainEventsRegisterAny has to be implemented manually */

static int
remoteDispatchDomainGetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_get_autostart_args *args,
    remote_domain_get_autostart_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int autostart;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainGetAutostart(dom, &autostart) < 0)
        goto cleanup;

    ret->autostart = autostart;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainGetBlkioParameters has to be implemented manually */

/* remoteDispatchDomainGetBlockInfo has to be implemented manually */

/* remoteDispatchDomainGetInfo has to be implemented manually */

/* remoteDispatchDomainGetJobInfo has to be implemented manually */

static int
remoteDispatchDomainGetMaxMemory(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_get_max_memory_args *args,
    remote_domain_get_max_memory_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    unsigned long memory;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((memory = virDomainGetMaxMemory(dom)) == 0)
        goto cleanup;

    ret->memory = memory;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainGetMaxVcpus(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_get_max_vcpus_args *args,
    remote_domain_get_max_vcpus_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((num = virDomainGetMaxVcpus(dom)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainGetMemoryParameters has to be implemented manually */

static int
remoteDispatchDomainGetOsType(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_get_os_type_args *args,
    remote_domain_get_os_type_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    char *type;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((type = virDomainGetOSType(dom)) == NULL)
        goto cleanup;

    ret->type = type;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainGetSchedulerParameters has to be implemented manually */

/* remoteDispatchDomainGetSchedulerType has to be implemented manually */

/* remoteDispatchDomainGetSecurityLabel has to be implemented manually */

/* remoteDispatchDomainGetVcpus has to be implemented manually */

static int
remoteDispatchDomainGetVcpusFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_get_vcpus_flags_args *args,
    remote_domain_get_vcpus_flags_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((num = virDomainGetVcpusFlags(dom, args->flags)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainHasCurrentSnapshot(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_has_current_snapshot_args *args,
    remote_domain_has_current_snapshot_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int result;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((result = virDomainHasCurrentSnapshot(dom, args->flags)) < 0)
        goto cleanup;

    ret->result = result;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainHasManagedSaveImage(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_has_managed_save_image_args *args,
    remote_domain_has_managed_save_image_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int result;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((result = virDomainHasManagedSaveImage(dom, args->flags)) < 0)
        goto cleanup;

    ret->result = result;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainInterfaceStats has to be implemented manually */

static int
remoteDispatchDomainIsActive(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_is_active_args *args,
    remote_domain_is_active_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int active;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((active = virDomainIsActive(dom)) < 0)
        goto cleanup;

    ret->active = active;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainIsPersistent(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_is_persistent_args *args,
    remote_domain_is_persistent_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int persistent;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((persistent = virDomainIsPersistent(dom)) < 0)
        goto cleanup;

    ret->persistent = persistent;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainIsUpdated(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_is_updated_args *args,
    remote_domain_is_updated_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int updated;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((updated = virDomainIsUpdated(dom)) < 0)
        goto cleanup;

    ret->updated = updated;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainLookupById has to be implemented manually */

/* remoteDispatchDomainLookupByName has to be implemented manually */

/* remoteDispatchDomainLookupByUUID has to be implemented manually */

static int
remoteDispatchDomainManagedSave(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_managed_save_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainManagedSave(dom, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainManagedSaveRemove(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_managed_save_remove_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainManagedSaveRemove(dom, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainMemoryPeek has to be implemented manually */

/* remoteDispatchDomainMemoryStats has to be implemented manually */

/* remoteDispatchDomainMigrateFinish has to be implemented manually */

/* remoteDispatchDomainMigrateFinish2 has to be implemented manually */

/* remoteDispatchDomainMigratePerform has to be implemented manually */

/* remoteDispatchDomainMigratePrepare has to be implemented manually */

/* remoteDispatchDomainMigratePrepare2 has to be implemented manually */

/* remoteDispatchDomainMigratePrepareTunnel has to be implemented manually */

static int
remoteDispatchDomainMigrateSetMaxDowntime(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_migrate_set_max_downtime_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainMigrateSetMaxDowntime(dom, args->downtime, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainMigrateSetMaxSpeed(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_migrate_set_max_speed_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainMigrateSetMaxSpeed(dom, args->bandwidth, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainOpenConsole has to be implemented manually */

/* remoteDispatchDomainPinVcpu has to be implemented manually */

static int
remoteDispatchDomainReboot(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_reboot_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainReboot(dom, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainRestore(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_restore_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (virDomainRestore(conn, args->from) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchDomainResume(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_resume_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainResume(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainRevertToSnapshot(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_revert_to_snapshot_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    virDomainSnapshotPtr snapshot = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->snap.dom)))
        goto cleanup;

    if (!(snapshot = get_nonnull_domain_snapshot(dom, args->snap)))
        goto cleanup;

    if (virDomainRevertToSnapshot(snapshot, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (snapshot)
        virDomainSnapshotFree(snapshot);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSave(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_save_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSave(dom, args->to) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_autostart_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetAutostart(dom, args->autostart) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSetBlkioParameters has to be implemented manually */

static int
remoteDispatchDomainSetMaxMemory(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_max_memory_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetMaxMemory(dom, args->memory) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetMemory(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_memory_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetMemory(dom, args->memory) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetMemoryFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_memory_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetMemoryFlags(dom, args->memory, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSetMemoryParameters has to be implemented manually */

/* remoteDispatchDomainSetSchedulerParameters has to be implemented manually */

static int
remoteDispatchDomainSetVcpus(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_vcpus_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetVcpus(dom, args->nvcpus) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSetVcpusFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_set_vcpus_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSetVcpusFlags(dom, args->nvcpus, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainShutdown(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_shutdown_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainShutdown(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSnapshotCreateXML has to be implemented manually */

/* remoteDispatchDomainSnapshotCurrent has to be implemented manually */

static int
remoteDispatchDomainSnapshotDelete(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_snapshot_delete_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    virDomainSnapshotPtr snapshot = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->snap.dom)))
        goto cleanup;

    if (!(snapshot = get_nonnull_domain_snapshot(dom, args->snap)))
        goto cleanup;

    if (virDomainSnapshotDelete(snapshot, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (snapshot)
        virDomainSnapshotFree(snapshot);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSnapshotDumpXML(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_snapshot_dump_xml_args *args,
    remote_domain_snapshot_dump_xml_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    virDomainSnapshotPtr snapshot = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->snap.dom)))
        goto cleanup;

    if (!(snapshot = get_nonnull_domain_snapshot(dom, args->snap)))
        goto cleanup;

    if ((xml = virDomainSnapshotGetXMLDesc(snapshot, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (snapshot)
        virDomainSnapshotFree(snapshot);
    if (dom)
        virDomainFree(dom);
    return rv;
}

/* remoteDispatchDomainSnapshotListNames has to be implemented manually */

/* remoteDispatchDomainSnapshotLookupByName has to be implemented manually */

static int
remoteDispatchDomainSnapshotNum(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_snapshot_num_args *args,
    remote_domain_snapshot_num_ret *ret)
{
    int rv = -1;
    virDomainPtr dom = NULL;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if ((num = virDomainSnapshotNum(dom, args->flags)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainSuspend(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_suspend_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainSuspend(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainUndefine(dom) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainUpdateDeviceFlags(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_update_device_flags_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virDomainPtr dom = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dom = get_nonnull_domain(conn, args->dom)))
        goto cleanup;

    if (virDomainUpdateDeviceFlags(dom, args->xml, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dom)
        virDomainFree(dom);
    return rv;
}

static int
remoteDispatchDomainXMLFromNative(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_xml_from_native_args *args,
    remote_domain_xml_from_native_ret *ret)
{
    int rv = -1;
    char *domainXml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((domainXml = virConnectDomainXMLFromNative(conn, args->nativeFormat, args->nativeConfig, args->flags)) == NULL)
        goto cleanup;

    ret->domainXml = domainXml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchDomainXMLToNative(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_domain_xml_to_native_args *args,
    remote_domain_xml_to_native_ret *ret)
{
    int rv = -1;
    char *nativeConfig;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((nativeConfig = virConnectDomainXMLToNative(conn, args->nativeFormat, args->domainXml, args->flags)) == NULL)
        goto cleanup;

    ret->nativeConfig = nativeConfig;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

/* remoteDispatchFindStoragePoolSources has to be implemented manually */

static int
remoteDispatchGetCapabilities(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_get_capabilities_ret *ret)
{
    int rv = -1;
    char *capabilities;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((capabilities = virConnectGetCapabilities(conn)) == NULL)
        goto cleanup;

    ret->capabilities = capabilities;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchGetHostname(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_get_hostname_ret *ret)
{
    int rv = -1;
    char *hostname;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((hostname = virConnectGetHostname(conn)) == NULL)
        goto cleanup;

    ret->hostname = hostname;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchGetLibVersion(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_get_lib_version_ret *ret)
{
    int rv = -1;
    unsigned long lib_ver;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (virConnectGetLibVersion(conn, &lib_ver) < 0)
        goto cleanup;

    ret->lib_ver = lib_ver;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

/* remoteDispatchGetMaxVcpus has to be implemented manually */

static int
remoteDispatchGetSysinfo(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_get_sysinfo_args *args,
    remote_get_sysinfo_ret *ret)
{
    int rv = -1;
    char *sysinfo;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((sysinfo = virConnectGetSysinfo(conn, args->flags)) == NULL)
        goto cleanup;

    ret->sysinfo = sysinfo;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

/* remoteDispatchGetType has to be implemented manually */

static int
remoteDispatchGetURI(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_get_uri_ret *ret)
{
    int rv = -1;
    char *uri;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((uri = virConnectGetURI(conn)) == NULL)
        goto cleanup;

    ret->uri = uri;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchGetVersion(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_get_version_ret *ret)
{
    int rv = -1;
    unsigned long hv_ver;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (virConnectGetVersion(conn, &hv_ver) < 0)
        goto cleanup;

    ret->hv_ver = hv_ver;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchInterfaceCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virInterfacePtr iface = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if (virInterfaceCreate(iface, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

/* remoteDispatchInterfaceDefineXML has to be implemented manually */

static int
remoteDispatchInterfaceDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virInterfacePtr iface = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if (virInterfaceDestroy(iface, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

static int
remoteDispatchInterfaceGetXMLDesc(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_get_xml_desc_args *args,
    remote_interface_get_xml_desc_ret *ret)
{
    int rv = -1;
    virInterfacePtr iface = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if ((xml = virInterfaceGetXMLDesc(iface, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

static int
remoteDispatchInterfaceIsActive(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_is_active_args *args,
    remote_interface_is_active_ret *ret)
{
    int rv = -1;
    virInterfacePtr iface = NULL;
    int active;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if ((active = virInterfaceIsActive(iface)) < 0)
        goto cleanup;

    ret->active = active;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

/* remoteDispatchInterfaceLookupByMacString has to be implemented manually */

/* remoteDispatchInterfaceLookupByName has to be implemented manually */

static int
remoteDispatchInterfaceUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_interface_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virInterfacePtr iface = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(iface = get_nonnull_interface(conn, args->iface)))
        goto cleanup;

    if (virInterfaceUndefine(iface) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (iface)
        virInterfaceFree(iface);
    return rv;
}

static int
remoteDispatchIsSecure(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_is_secure_ret *ret)
{
    int rv = -1;
    int secure;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((secure = virConnectIsSecure(conn)) < 0)
        goto cleanup;

    ret->secure = secure;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

/* remoteDispatchListDefinedDomains has to be implemented manually */

/* remoteDispatchListDefinedInterfaces has to be implemented manually */

/* remoteDispatchListDefinedNetworks has to be implemented manually */

/* remoteDispatchListDefinedStoragePools has to be implemented manually */

/* remoteDispatchListDomains has to be implemented manually */

/* remoteDispatchListInterfaces has to be implemented manually */

/* remoteDispatchListNetworks has to be implemented manually */

/* remoteDispatchListNWFilters has to be implemented manually */

/* remoteDispatchListSecrets has to be implemented manually */

/* remoteDispatchListStoragePools has to be implemented manually */

static int
remoteDispatchNetworkCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkCreate(net) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

/* remoteDispatchNetworkCreateXML has to be implemented manually */

/* remoteDispatchNetworkDefineXML has to be implemented manually */

static int
remoteDispatchNetworkDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkDestroy(net) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

static int
remoteDispatchNetworkDumpXML(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_dump_xml_args *args,
    remote_network_dump_xml_ret *ret)
{
    int rv = -1;
    virNetworkPtr net = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if ((xml = virNetworkGetXMLDesc(net, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

static int
remoteDispatchNetworkGetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_get_autostart_args *args,
    remote_network_get_autostart_ret *ret)
{
    int rv = -1;
    virNetworkPtr net = NULL;
    int autostart;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkGetAutostart(net, &autostart) < 0)
        goto cleanup;

    ret->autostart = autostart;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

static int
remoteDispatchNetworkGetBridgeName(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_get_bridge_name_args *args,
    remote_network_get_bridge_name_ret *ret)
{
    int rv = -1;
    virNetworkPtr net = NULL;
    char *name;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if ((name = virNetworkGetBridgeName(net)) == NULL)
        goto cleanup;

    ret->name = name;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

static int
remoteDispatchNetworkIsActive(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_is_active_args *args,
    remote_network_is_active_ret *ret)
{
    int rv = -1;
    virNetworkPtr net = NULL;
    int active;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if ((active = virNetworkIsActive(net)) < 0)
        goto cleanup;

    ret->active = active;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

static int
remoteDispatchNetworkIsPersistent(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_is_persistent_args *args,
    remote_network_is_persistent_ret *ret)
{
    int rv = -1;
    virNetworkPtr net = NULL;
    int persistent;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if ((persistent = virNetworkIsPersistent(net)) < 0)
        goto cleanup;

    ret->persistent = persistent;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

/* remoteDispatchNetworkLookupByName has to be implemented manually */

/* remoteDispatchNetworkLookupByUUID has to be implemented manually */

static int
remoteDispatchNetworkSetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_set_autostart_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkSetAutostart(net, args->autostart) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

static int
remoteDispatchNetworkUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_network_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNetworkPtr net = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(net = get_nonnull_network(conn, args->net)))
        goto cleanup;

    if (virNetworkUndefine(net) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (net)
        virNetworkFree(net);
    return rv;
}

/* remoteDispatchNodeDeviceCreateXML has to be implemented manually */

static int
remoteDispatchNodeDeviceDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceDestroy(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

static int
remoteDispatchNodeDeviceDettach(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_dettach_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceDettach(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

static int
remoteDispatchNodeDeviceDumpXML(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_dump_xml_args *args,
    remote_node_device_dump_xml_ret *ret)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if ((xml = virNodeDeviceGetXMLDesc(dev, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

/* remoteDispatchNodeDeviceGetParent has to be implemented manually */

/* remoteDispatchNodeDeviceListCaps has to be implemented manually */

/* remoteDispatchNodeDeviceLookupByName has to be implemented manually */

static int
remoteDispatchNodeDeviceNumOfCaps(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_num_of_caps_args *args,
    remote_node_device_num_of_caps_ret *ret)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if ((num = virNodeDeviceNumOfCaps(dev)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

static int
remoteDispatchNodeDeviceReAttach(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_re_attach_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceReAttach(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

static int
remoteDispatchNodeDeviceReset(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_node_device_reset_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNodeDevicePtr dev = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(dev = virNodeDeviceLookupByName(conn, args->name)))
        goto cleanup;

    if (virNodeDeviceReset(dev) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (dev)
        virNodeDeviceFree(dev);
    return rv;
}

/* remoteDispatchNodeGetCellsFreeMemory has to be implemented manually */

/* remoteDispatchNodeGetFreeMemory has to be implemented manually */

/* remoteDispatchNodeGetInfo has to be implemented manually */

/* remoteDispatchNodeGetSecurityModel has to be implemented manually */

/* remoteDispatchNodeListDevices has to be implemented manually */

/* remoteDispatchNodeNumOfDevices has to be implemented manually */

static int
remoteDispatchNumOfDefinedDomains(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_defined_domains_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfDefinedDomains(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfDefinedInterfaces(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_defined_interfaces_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfDefinedInterfaces(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfDefinedNetworks(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_defined_networks_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfDefinedNetworks(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfDefinedStoragePools(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_defined_storage_pools_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfDefinedStoragePools(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfDomains(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_domains_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfDomains(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfInterfaces(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_interfaces_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfInterfaces(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfNetworks(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_networks_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfNetworks(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfNWFilters(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_nwfilters_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfNWFilters(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfSecrets(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_secrets_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfSecrets(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

static int
remoteDispatchNumOfStoragePools(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    void *args ATTRIBUTE_UNUSED,
    remote_num_of_storage_pools_ret *ret)
{
    int rv = -1;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((num = virConnectNumOfStoragePools(conn)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}

/* remoteDispatchNWFilterDefineXML has to be implemented manually */

static int
remoteDispatchNWFilterGetXMLDesc(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_nwfilter_get_xml_desc_args *args,
    remote_nwfilter_get_xml_desc_ret *ret)
{
    int rv = -1;
    virNWFilterPtr nwfilter = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(nwfilter = get_nonnull_nwfilter(conn, args->nwfilter)))
        goto cleanup;

    if ((xml = virNWFilterGetXMLDesc(nwfilter, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (nwfilter)
        virNWFilterFree(nwfilter);
    return rv;
}

/* remoteDispatchNWFilterLookupByName has to be implemented manually */

/* remoteDispatchNWFilterLookupByUUID has to be implemented manually */

static int
remoteDispatchNWFilterUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_nwfilter_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virNWFilterPtr nwfilter = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(nwfilter = get_nonnull_nwfilter(conn, args->nwfilter)))
        goto cleanup;

    if (virNWFilterUndefine(nwfilter) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (nwfilter)
        virNWFilterFree(nwfilter);
    return rv;
}

/* remoteDispatchOpen has to be implemented manually */

/* remoteDispatchSecretDefineXML has to be implemented manually */

/* remoteDispatchSecretGetValue has to be implemented manually */

static int
remoteDispatchSecretGetXMLDesc(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_secret_get_xml_desc_args *args,
    remote_secret_get_xml_desc_ret *ret)
{
    int rv = -1;
    virSecretPtr secret = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(secret = get_nonnull_secret(conn, args->secret)))
        goto cleanup;

    if ((xml = virSecretGetXMLDesc(secret, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (secret)
        virSecretFree(secret);
    return rv;
}

/* remoteDispatchSecretLookupByUsage has to be implemented manually */

/* remoteDispatchSecretLookupByUUID has to be implemented manually */

static int
remoteDispatchSecretSetValue(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_secret_set_value_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virSecretPtr secret = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(secret = get_nonnull_secret(conn, args->secret)))
        goto cleanup;

    if (virSecretSetValue(secret, (const unsigned char *)args->value.value_val, args->value.value_len, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (secret)
        virSecretFree(secret);
    return rv;
}

static int
remoteDispatchSecretUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_secret_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virSecretPtr secret = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(secret = get_nonnull_secret(conn, args->secret)))
        goto cleanup;

    if (virSecretUndefine(secret) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (secret)
        virSecretFree(secret);
    return rv;
}

static int
remoteDispatchStoragePoolBuild(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_build_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolBuild(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolCreate(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_create_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolCreate(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

/* remoteDispatchStoragePoolCreateXML has to be implemented manually */

/* remoteDispatchStoragePoolDefineXML has to be implemented manually */

static int
remoteDispatchStoragePoolDelete(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_delete_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolDelete(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolDestroy(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_destroy_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolDestroy(pool) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolDumpXML(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_dump_xml_args *args,
    remote_storage_pool_dump_xml_ret *ret)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if ((xml = virStoragePoolGetXMLDesc(pool, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolGetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_get_autostart_args *args,
    remote_storage_pool_get_autostart_ret *ret)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;
    int autostart;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolGetAutostart(pool, &autostart) < 0)
        goto cleanup;

    ret->autostart = autostart;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

/* remoteDispatchStoragePoolGetInfo has to be implemented manually */

static int
remoteDispatchStoragePoolIsActive(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_is_active_args *args,
    remote_storage_pool_is_active_ret *ret)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;
    int active;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if ((active = virStoragePoolIsActive(pool)) < 0)
        goto cleanup;

    ret->active = active;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolIsPersistent(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_is_persistent_args *args,
    remote_storage_pool_is_persistent_ret *ret)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;
    int persistent;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if ((persistent = virStoragePoolIsPersistent(pool)) < 0)
        goto cleanup;

    ret->persistent = persistent;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

/* remoteDispatchStoragePoolListVolumes has to be implemented manually */

/* remoteDispatchStoragePoolLookupByName has to be implemented manually */

/* remoteDispatchStoragePoolLookupByUUID has to be implemented manually */

/* remoteDispatchStoragePoolLookupByVolume has to be implemented manually */

static int
remoteDispatchStoragePoolNumOfVolumes(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_num_of_volumes_args *args,
    remote_storage_pool_num_of_volumes_ret *ret)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;
    int num;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if ((num = virStoragePoolNumOfVolumes(pool)) < 0)
        goto cleanup;

    ret->num = num;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolRefresh(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_refresh_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolRefresh(pool, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolSetAutostart(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_set_autostart_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolSetAutostart(pool, args->autostart) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

static int
remoteDispatchStoragePoolUndefine(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_pool_undefine_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStoragePoolPtr pool = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(pool = get_nonnull_storage_pool(conn, args->pool)))
        goto cleanup;

    if (virStoragePoolUndefine(pool) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (pool)
        virStoragePoolFree(pool);
    return rv;
}

/* remoteDispatchStorageVolCreateXML has to be implemented manually */

/* remoteDispatchStorageVolCreateXMLFrom has to be implemented manually */

static int
remoteDispatchStorageVolDelete(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_vol_delete_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStorageVolPtr vol = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(vol = get_nonnull_storage_vol(conn, args->vol)))
        goto cleanup;

    if (virStorageVolDelete(vol, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (vol)
        virStorageVolFree(vol);
    return rv;
}

/* remoteDispatchStorageVolDownload has to be implemented manually */

static int
remoteDispatchStorageVolDumpXML(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_vol_dump_xml_args *args,
    remote_storage_vol_dump_xml_ret *ret)
{
    int rv = -1;
    virStorageVolPtr vol = NULL;
    char *xml;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(vol = get_nonnull_storage_vol(conn, args->vol)))
        goto cleanup;

    if ((xml = virStorageVolGetXMLDesc(vol, args->flags)) == NULL)
        goto cleanup;

    ret->xml = xml;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (vol)
        virStorageVolFree(vol);
    return rv;
}

/* remoteDispatchStorageVolGetInfo has to be implemented manually */

static int
remoteDispatchStorageVolGetPath(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_vol_get_path_args *args,
    remote_storage_vol_get_path_ret *ret)
{
    int rv = -1;
    virStorageVolPtr vol = NULL;
    char *name;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(vol = get_nonnull_storage_vol(conn, args->vol)))
        goto cleanup;

    if ((name = virStorageVolGetPath(vol)) == NULL)
        goto cleanup;

    ret->name = name;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (vol)
        virStorageVolFree(vol);
    return rv;
}

/* remoteDispatchStorageVolLookupByKey has to be implemented manually */

/* remoteDispatchStorageVolLookupByName has to be implemented manually */

/* remoteDispatchStorageVolLookupByPath has to be implemented manually */

/* remoteDispatchStorageVolUpload has to be implemented manually */

static int
remoteDispatchStorageVolWipe(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_storage_vol_wipe_args *args,
    void *ret ATTRIBUTE_UNUSED)
{
    int rv = -1;
    virStorageVolPtr vol = NULL;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (!(vol = get_nonnull_storage_vol(conn, args->vol)))
        goto cleanup;

    if (virStorageVolWipe(vol, args->flags) < 0)
        goto cleanup;

    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    if (vol)
        virStorageVolFree(vol);
    return rv;
}

static int
remoteDispatchSupportsFeature(
    struct qemud_server *server ATTRIBUTE_UNUSED,
    struct qemud_client *client ATTRIBUTE_UNUSED,
    virConnectPtr conn,
    remote_message_header *hdr ATTRIBUTE_UNUSED,
    remote_error *rerr,
    remote_supports_feature_args *args,
    remote_supports_feature_ret *ret)
{
    int rv = -1;
    int supported;

    if (!conn) {
        virNetError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if ((supported = virDrvSupportsFeature(conn, args->feature)) < 0)
        goto cleanup;

    ret->supported = supported;
    rv = 0;

cleanup:
    if (rv < 0)
        remoteDispatchError(rerr);
    return rv;
}
